{
  "_args": [
    [
      {
        "raw": "btc-swap@github:etherex/btc-swap",
        "scope": null,
        "escapedName": "btc-swap",
        "name": "btc-swap",
        "rawSpec": "github:etherex/btc-swap",
        "spec": "github:etherex/btc-swap",
        "type": "hosted",
        "hosted": {
          "type": "github",
          "ssh": "git@github.com:etherex/btc-swap.git",
          "sshUrl": "git+ssh://git@github.com/etherex/btc-swap.git",
          "httpsUrl": "git+https://github.com/etherex/btc-swap.git",
          "gitUrl": "git://github.com/etherex/btc-swap.git",
          "shortcut": "github:etherex/btc-swap",
          "directUrl": "https://raw.githubusercontent.com/etherex/btc-swap/master/package.json"
        }
      },
      "/Users/Admin/lnchpad.info/etherex/frontend"
    ]
  ],
  "_from": "etherex/btc-swap",
  "_id": "btc-swap@0.2.0",
  "_inCache": true,
  "_location": "/btc-swap",
  "_phantomChildren": {},
  "_requested": {
    "raw": "btc-swap@github:etherex/btc-swap",
    "scope": null,
    "escapedName": "btc-swap",
    "name": "btc-swap",
    "rawSpec": "github:etherex/btc-swap",
    "spec": "github:etherex/btc-swap",
    "type": "hosted",
    "hosted": {
      "type": "github",
      "ssh": "git@github.com:etherex/btc-swap.git",
      "sshUrl": "git+ssh://git@github.com/etherex/btc-swap.git",
      "httpsUrl": "git+https://github.com/etherex/btc-swap.git",
      "gitUrl": "git://github.com/etherex/btc-swap.git",
      "shortcut": "github:etherex/btc-swap",
      "directUrl": "https://raw.githubusercontent.com/etherex/btc-swap/master/package.json"
    }
  },
  "_requiredBy": [
    "/"
  ],
  "_resolved": "git://github.com/etherex/btc-swap.git#78b816a9c53b5284783f6e3366ee27fff40f2981",
  "_shasum": "9ed0044dd68b80f7104466f06632fca68881f616",
  "_shrinkwrap": null,
  "_spec": "btc-swap@github:etherex/btc-swap",
  "_where": "/Users/Admin/lnchpad.info/etherex/frontend",
  "author": {
    "name": "AJoseph"
  },
  "bugs": {
    "url": "https://github.com/etherex/btc-swap/issues"
  },
  "dependencies": {
    "bignumber.js": "^2.1.1",
    "bitcoin-proof": "^2.0.0",
    "bitcoinjs-lib": "=1.5.8",
    "cb-blockr": "^3.1.2",
    "web3": "^0.15.1"
  },
  "description": "Ethereum Bitcoin Swap library",
  "devDependencies": {
    "babel-core": "^6.3.15",
    "babel-preset-es2015": "^6.3.13",
    "eslint": "^1.10.3",
    "grunt": "^0.4.5",
    "grunt-babel": "^6.0.0",
    "grunt-contrib-watch": "^0.6.1",
    "grunt-eslint": "^17.3.1",
    "grunt-mocha-cli": "^2.0.0",
    "mocha": "^2.3.4"
  },
  "gitHead": "78b816a9c53b5284783f6e3366ee27fff40f2981",
  "homepage": "https://github.com/etherex/btc-swap#readme",
  "keywords": [
    "EtherEx",
    "Ethereum",
    "Bitcoin"
  ],
  "license": "MIT",
  "main": "lib/btc-swap.js",
  "name": "btc-swap",
  "optionalDependencies": {},
  "private": true,
  "readme": "# Ethereum BTC Swap\n[![Build Status](https://travis-ci.org/etherex/btc-swap.svg)](https://travis-ci.org/etherex/btc-swap)\n[![Dependency Status](https://david-dm.org/etherex/btc-swap.svg)](https://david-dm.org/etherex/btc-swap)\n[![devDependency Status](https://david-dm.org/etherex/btc-swap/dev-status.svg)](https://david-dm.org/etherex/btc-swap#info=devDependencies)\n\n## Installation\n```\nnpm install --save etherex/btc-swap\n```\n\n## Usage\n```\nvar BtcSwap = require('btc-swap');\nvar client = new BtcSwap({\n  address: \"0x4491959fe1772faa7332464b0e7f1aa9aa2d8446\", // Address of the BtcSwap contract\n  host: \"localhost:8545\", // Ethereum node\n  from: \"0xcd2a3d9f938e13cd947ec05abc7fe734df8dd826\", // Ethereum account\n  testnet: true, // Use BTC testnet, defaults to true\n  debug: true\n});\n```\n\n## Methods\nFor any method with a `failure` callback, any error will fire that callback\nbefore aborting the execution of that method.\n\n#### `lookupTicket(ticketId, success, failure)`\nReturns a ticket object specified by `ticketId` to the `success` callback.\n\n#### `createTicket(btcAddress, numEther, btcTotal, success, completed, failure)`\nCreate a ticket for `btcAddress` of `numEther` for `btcTotal`. The `success`\ncallback gets fired when the Ethereum transaction is sent and returns the\ntransaction hash. The `completed` callback gets fired when the transaction\nis mined, returns the same transaction hash as first parameter and the created\nticket object as second parameter.\n\n#### `reserveTicket(ticketId, txHash, powNonce, success, completed, failure)`\nReserve a ticket with ID `ticketId`, with the BTC transaction hash `txHash`\nand computed nonce `powNonce` (see `computePoW()`). The `success` callback\ngets fired when the Ethereum transaction is sent, returns the ticket ID as\nfirst parameter and the Ethereum transaction hash as second parameter. The\n`completed` callback gets fired when the transaction is mined and returns the\nreserved ticket object.\n\n#### `claimTicket(ticketId, txHex, txHash, txIndex, merkleSibling, txBlockHash,\n  feeWei, success, completed, failure)`\nClaim a ticket with ID `ticketId`, with the signed BTC transaction hex `txHex`,\nthe BTC transaction hash `txHash`, BTC transaction index `txIndex`, BTC merkle\nsiblings `merkleSibling` and BTC block hash `txBlockHash`. `feeWei` can be\nobtained by calling `getFeeAmount(txBlockHash)` and will be the transaction's\nvalue if it's above zero. The `success` callback gets fired when the Ethereum\ntransaction is sent and returns the Ethereum transaction hash. The `completed`\ncallback gets fired when the transaction is mined and returns the ticket ID.\n\n#### `cancelTicket(ticketId, success, failure)`\nCancel a ticket with `ticketId`, if the ticket is still reservable and by\nthe creator of that ticket only. The `success` callback gets fired when the\nEthereum transaction is sent and returns the ticket ID as first parameter and\nthe Ethereum transaction hash as second parameter. The `completed` callback gets\nfired when the transaction is mined and returns the ticket ID that was just\ncanceled.\n\n## Ticket ID list\n#### `getTicketIDs(success, failure)`\nReturns open ticket IDs. Use with `lookupTicket()` to load all currently open\ntickets.\n\n## Watch filter\n#### `watchTickets(ticketEvent, failure)`\nSets a global watch filter for all ticket events, which calls `ticketEvent` that\nreturns `new`, `reserved` or `removed` as first parameter, and the ticket ID\nas second parameter. Use this to watch tickets created, reserved, claimed or\ncanceled by other users. Take note that this filter will also trigger on the\nsame events as the other methods' `completed` callbacks.\n\n## Proof of Work nonce\n#### `computePoW(ticketId, btcTxHash, success, failure)`\nCompute a nonce for a ticket with ID `ticketId`, with the BTC transaction hash\n`txHash`. The `success` callback gets fired when a nonce is found.\n\n#### `verifyPoW(ticketId, txHash, nonce, success, failure)`\nVerify a nonce for a ticket with ID `ticketId`, with the BTC transaction hash\n`txHash` and previously computed `nonce`. The `success` callback gets fired\nwhen the nonce is found to be valid with a success message, same with the\n`failure` callback when the nonce is invalid.\n\n## Intermediate wallet methods\n#### `generateWallet(success, failure)`\nGenerate an intermediate wallet to be used for reserving and claiming a ticket.\nThe `success` callback gets fired when the wallet is successfully generated and\nreturns a wallet object with the address and WIF key.\n\n#### `importWallet(wif, success, failure)`\nImport a previously generated wallet using the WIF key from `wif`. The success\ncallback gets fired on successful importation of the wallet and returns a\nwallet object with the address and the same WIF key.\n\n#### `createTransaction(wallet, recipient, amountBtc, etherFee, etherAddress, success, failure)`\nCreate a signed BTC transaction to get a transaction hash for `reserveTicket()`\nto be later broadcast with `propagateTransaction()` (see below), using a\nwallet object `wallet` (as returned by `generateWallet()`), paid to the BTC\naddress `recipient` for the amount of `amountBtc`, including an ether fee of\n`etherFee` for a third-party claimer, and from the Ethereum address\n`etherAddress`. The `success` callback gets fired when the transaction is\nsuccessfully created and returns an object with `fee` for the actual BTC miner\nfee after the `etherAddress` and `etherFee` have been encoded into the\ntransaction, the `hash` of the BTC transaction and `hex` of the raw transaction.\n\n#### `propagateTransaction(txHex, success, failure)`\nBroadcast a previously signed raw transaction `txHex` to the Bitcoin network.\nThe `success` callback gets fired when the transaction is successfully broadcast\nand returns the BTC transaction hash.\n\n## BTC relay methods\n#### `getBlockchainHead(success, failure)`\nQuery the [btcrelay](https://github.com/ethereum/btcrelay) contract for its last\nstored BTC block hash. The `success` callback gets fired on a successful call\nand returns the hash of the latest block.\n\n#### `getLastBlockHeight(success, failure)`\nQuery the [btcrelay](https://github.com/ethereum/btcrelay) contract for its last\nstored BTC block number. The `success` callback gets fired on a successful call\nand returns the block number of the latest block.\n\n#### `getFeeAmount(blockHash, success, failure)`\nGet the fee from [btcrelay](https://github.com/ethereum/btcrelay) to validate a\ntransaction in a given `blockHash`. The `success` callback gets fired on a\nsuccessful call and returns the fee amount in wei.\n\n#### `storeBlockWithFee(blockHash, feeWei, success, failure)`\nQuery the [blockr](https://blockr.io) API for the raw block data of a block\nwith hash `blockHash`, generate the BTC block header from that data, call the\n`storeBlockWithFee` method of [btcrelay](https://github.com/ethereum/btcrelay)\nand send an Ethereum transaction for that same method if successful, effectively\nstoring the block header. The `success` callback gets fired when the transaction\nis mined and returns the BTC block number for which the block header was stored.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/etherex/btc-swap.git"
  },
  "scripts": {
    "test": "grunt build && mocha"
  },
  "version": "0.2.0"
}
